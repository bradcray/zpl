/******************************************************************************

            Copyright (c) 1996 - 2004  --  University of Washington

******************************************************************************/

/***
 *** file:          error.h
 *** description:   This file describes the macros for error reporting
 *** author:        Sung-Eun Choi (with help from E)
 *** date:          7 January 1996
 *** modifications:
 ***
 *** NOTICE:
 ***    ANY PERSONS WRITING CODE FOR THE ZPL COMPILER SHALL AGREE
 ***    TO USE ONLY THE FOLLOWING MECHANISMS FOR REPORTING ERRORS,
 ***    WARNINGS OR ANY OTHER MESSAGES TO THE USER.
 ***
 ***    I, ________________________, swear on the holy ZPL User's
 ***    Guide that I will abide by the preceeding decree and never
 ***    use "fprintf(stderr, ...)".
 ***
 ***                                                    +-----+
 ***                                                    |     |
 ***                                                    |     |
 ***    ------------------------------------            +-----+
 ***                signature                         drop of blood
 ***
 ***
 *** ZPL ERROR REPORTING
 ***    There are two types of errors that may occur during the
 ***    ZPL compilation process: user and internal.  User errors
 ***    are reported when a program is incorrect (e.g. syntax
 ***    errors or type mismatches.)  You may also want to warn
 ***    users of unimplemented language features or possibly
 ***    erroneous situations that may occur at run-time or later
 ***    in the compilation process.  Internal errors should be
 ***    reported when the compiler itself malfunctions (e.g. "You
 ***    should never reach this piece of code!" or "Ahh!!!  Contact
 ***    Brad immediately!")
 ***
 *** Macro Name Format:
 ***    Each macro name describes the exact purpose of the macro.
 ***    The format of the macro names is as follows:
 ***
 ***        type_[COND_]error_[CONT_]x ( ... )
 ***
 ***        type   is INT (internal) or USR (user) or YY (parser)
 ***        COND   is conditional and the first argument is the
 ***               condition
 ***        error  is FATAL (terminating error) or WARN (warning)
 ***        CONT   is terminating error, but continue through end of
 ***               the pass or until too many errors are seen
 ***	    x      is nothing when you are passing in a statement,
 ***	           or X when you are explicitly passing in a line
 ***	           number and filename
 ***
 *** Errors:
 ***    All errors or warnings shall be reported via the
 ***    following macros:
 ***
 ***	USR_WARN(stmt, fmt, ...)
 ***	USR_FATAL(stmt, fmt, ...)
 ***	USR_FATAL_CONT(stmt, fmt, ...)
 ***	USR_COND_FATAL(c, stmt, fmt, ...)
 ***	INT_FATAL(stmt, fmt, ...)
 ***	INT_COND_FATAL(c, stmt, fmt, ...)
 ***
 ***	USR_WARNX(line, file, fmt, ...)
 ***	USR_FATALX(line, file, fmt, ...)
 ***	USR_FATAL_CONTX(line, file, fmt, ...)
 ***	INT_FATALX(line, file, fmt, ...)
 ***
 ***	YY_WARNX(line, file, fmt, ...)
 ***	YY_FATALX(line, file, fmt, ...)
 ***	YY_FATAL_CONTX(line, file, fmt, ...)
 ***
 ***    where "c" is an integer condition that must be true at the given
 ***    program point, "fmt" is a semi-informative message string, 
 ***	stmt is the statement that involves the error, line and file
 ***	are the source line number and filename that describe where the
 ***	error happened.  A NULL value for stmt or file is okay, and
 ***	a negative value for line will surpress it getting printed.
 ***
 *** Internal Error Numbers:
 ***    Internal errors will be identified by a compiler generated
 ***    error number.  The error number is the checksum of the
 ***    the string generated by concatenating the following:
 ***    
 ***        first 3 letters of source file name
 ***         + last 2 letters of source file name
 ***        (or whole filename is less that 5 characters long)
 ***        line number of error in source file
 ***        the letter "V"
 ***        ZPL version number
 ***
 *** Using CONT Errors (adapted from E's original implmentation)
 ***
 ***    The CONT macros allow a pass to continue even after a
 ***    fatal error has been detected.  This is useful, for
 ***    example, in type checking where you would like to display
 ***    as muchinformation as possible before quiting.
 ***
 ***    Early in the pass, you must use FATALCONTINIT(), and at
 ***    the end of the pass, you must use FATALCONTDONE(), which
 ***    will exit if there were any fatal errors in the pass.
 ***    After FATALMAX fatal errors, any use of FATALCONT will exit.
 ***
 ***/

#ifndef __ERROR_H_
#define __ERROR_H_
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include "parsetree.h"

void setup_error(char *filename, int linenumber);
void usr_warnx(int lineno, char *filename, char *fmt, ...);
void usr_fatalx(int lineno, char *filename, char *fmt, ...);
void usr_fatal_contx(int lineno, char *filename, char *fmt, ...);
void int_fatalx(int lineno, char *filename, char *fmt, ...);

void usr_warn(statement_t *s, char *fmt, ...);
void usr_fatal(statement_t *s, char *fmt, ...);
void usr_fatal_cont(statement_t *s, char *fmt, ...);
void usr_cond_fatal(int c, statement_t *s, char *fmt, ...);
void int_fatal(statement_t *s, char *fmt, ...);
void int_cond_fatal(int c, statement_t *s, char *fmt, ...);
void display_int_fatal(int lineno, char *filename, char *fmt, va_list args);
void display_usr(char *kind, int sourceline, char *sourcefile, char *fmt, 
		  va_list args);
void __ZPL_INT_FATAL(char *, int);


#define __ZPL_USR_EXIT() exit(1)
#define __ZPL_INT_EXIT() exit(1)

#define USR_WARN usr_warn
#define USR_FATAL usr_fatal
#define USR_FATAL_CONT usr_fatal_cont
#define USR_COND_FATAL usr_cond_fatal
#define INT_COND_FATAL setup_error(__FILE__, __LINE__); int_cond_fatal
#define INT_FATAL setup_error(__FILE__, __LINE__); int_fatal

#define USR_WARNX usr_warnx
#define USR_FATALX usr_fatalx
#define USR_FATAL_CONTX usr_fatal_contx
#define INT_FATALX setup_error(__FILE__, __LINE__); int_fatalx

#define YY_WARNX if (verbose) __ZPL_PRINT_SOURCE_LINE(); usr_warnx
#define YY_FATALX if (verbose) __ZPL_PRINT_SOURCE_LINE(); usr_fatalx
#define YY_FATAL_CONTX if (verbose) __ZPL_PRINT_SOURCE_LINE(); usr_fatal_contx

#define yyerror(msg) YY_FATAL_CONTX(yylineno, in_file, msg)

#define FATALMAX 10
#define FATALCONTINIT() { \
     fatal_count = 0; \
     }
#define FATALCONTDONE() { \
     if (fatal_count > 0) \
       __ZPL_USR_EXIT(); \
     }

void __ZPL_PRINT_SOURCE_LINE(void);

#endif
